<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


<head>
    <title>Ajax Poule vak 402</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="navbar">
    <div id="loginDiv">
        <a href="#" id="loginButton">
            <i class="fas fa-user user-icon" id="userIcon"> </i> Login
        </a>
    </div>
    <div id="menuItems" hidden>
        <a href="#" id="homeButton">Home</a>
        <a href="#" id="allMatchesButton">Wedstrijden</a>
        <a href="#" id="rulesButton">Regels</a>
        <a href="#" id="logOutButton">Log Uit</a>
    </div>
    <div id="userInfoDiv" style="display: none;">
        <a href="#">
            <i class="fas fa-user user-icon" id="userInfoIcon"></i> <span id="userName"> Gebruikersnaam </span>
        </a>
    </div>
</div>

<div id="mainContainer" class="mainContainer">


    <div class="login-window" id="auth-section" style="display: none;">
        <input type="email" id="email" placeholder="Email">
        <input type="password" id="password" placeholder="Password">
        <button id="signInButton">Log in</button>
        <button id="updatePassword"> Reset wachtwoord </button>
    </div>

    <div id="rules" style="display: none;">
        <div id="general_rules">
            <h3> Algemeen </h3>
            <ul>
                <li> Voorspellingen kunnen tot de officiÃ«le aanvang worden ingevuld </li>
                <li> Men dient altijd een overwinning voor Ajax te voorspellen </li>
                <li> Men dient geen voorspelling te doen die reeds gedaan is</li>
            </ul>
            <h3> Puntentelling </h3>
            <ul>
                <li> Winnaar goed: 1 punt </li>
                <li> Juiste aantal doelpunten van Ajax: 1 punt </li>
                <li> Juiste verschil in doelpunten: 1 punt </li>
            </ul>
            <p> Voorbeeld: je voorspelt 2-1 voor Ajax en het wordt helaas 2-3.
                Dan krijg je 1 punt, omdat je het aantal doelpunten van Ajax goed hebt voorspeld.</p>
            <h3> Aanwezigheid </h3>
            <ul>
                <li> Er zijn bonuspunten te verdienen door veel wedstrijden bij te wonen. </li>
                <li> De nummer 1 krijgt 3 bonuspunten, de nummer 2 krijgt er 2 en de nummer 3 krijgt er 1. </li>
                <li> Bij gelijke stand krijgt ieder het aantal punten dat hoort bij de gedeelde plek. </li>
            </ul>
            <p> Voorbeeld: Jonah en Tim worden gedeeld 1e en Koen en Bart gedeeld 3e. Dan krijgen Jonah en Tim allebei 3 punten en Koen en Bart krijgen allebei 1 punt.</p>
        </div>
    </div>

    <div id="match_prediction" style="display: none;">
        <div>
            <form class="prediction-form" action="#" method="post">
                <p class="match-date" id="next_match_date"></p>
                <div class="score-input-container">
                    <label for="home_score" id="home_team"></label>
                    <input type="number" id="home_score" name="home_score" min="0" required>
                    <span>-</span>
                    <input type="number" id="away_score" name="away_score" min="0" required>
                    <label for="away_score" id="away_team"></label>
                </div>
                <button class="small-button" id="addPrediction">Verstuur Voorspelling</button>
            </form>
        </div>
        <hr>

        <div class="section">
            <h2> Voorspellingen </h2>
            <table id="prediction_table" class="prediction-tables">
                <tr>
                    <th> Deelnemer </th>
                    <th> Voorspelling </th>
                </tr>
                <tbody></tbody>
            </table>
        </div>
        <hr>

        <div class="section" style="margin-top: 20px">
            <h2> Stand </h2>
            <table id="ranking_table" class="prediction-tables">
                <tr>
                    <th> Naam </th>
                    <th> Winnaar </th>
                    <th> Ajax Goals </th>
                    <th> Doelsaldo </th>
                    <th> Totaal </th>
                </tr>
                <tbody></tbody>
            </table>
        </div>
        <hr>
        <div class="section">
            <h2> Aanwezigheid </h2>
            <table id="attendance_ranking_table" class="prediction-tables">
                <tr>
                    <th> Naam </th>
                    <th> Aantal </th>
                </tr>
                <tbody></tbody>
            </table>
        </div>
        <hr>
    </div>

    <div id="matchesDiv" style="display: none">
        <div class="section">
            <h2> Wedstrijden </h2>
            <table id="allMatches" class="prediction-tables" style="width: 100%">
                <tr>
                    <th> Ronde </th>
                    <th> Datum </th>
                    <th> Thuis </th>
                    <th> Uit </th>
                    <th> Uitslag </th>
                </tr>
                <tbody></tbody>
            </table>
        </div>
    </div>

</div>

<div id="nextPredictionId" style="display: none;"></div>
<div id="predictedHomeScore" style="display: none;"></div>
<div id="predictedAwayScore" style="display: none;"></div>


<script type="module">
    // Import the core Firebase App and Cloud Firestore services
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";

    import { getAuth, sendPasswordResetEmail, updateProfile, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
    import { getFirestore, collection, getDocs, addDoc, setDoc, doc, query, orderBy } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

    // Your web app's Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyADh9mOGIa9tK8sGb9fu6PHUm-anH8aRPw",
        authDomain: "voetbalpoule-aef18.firebaseapp.com",
        databaseURL: "https://voetbalpoule-aef18-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "voetbalpoule-aef18",
        storageBucket: "voetbalpoule-aef18.firebasestorage.app",
        messagingSenderId: "678980778754",
        appId: "1:678980778754:web:582c0f3d6487651b9ea01b"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);

    // Initialize Cloud Firestore and get a reference to the service
    const db = getFirestore(app);

    // Get references to HTML elements
    const mainContainer = document.getElementById('mainContainer');
    const predictionDiv = document.getElementById("match_prediction");
    const auth = getAuth(app);
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');
    const loginButton = document.getElementById("loginButton");
    const signInButton = document.getElementById('signInButton');
    const authSectionDiv = document.getElementById('auth-section');
    const addPredictionButton = document.getElementById("addPrediction");
    const resetPasswordButton = document.getElementById("updatePassword");

    // Global variables

    let matches;
    let nextMatch;
    let users;
    let allPredictions;     // dict with matchId als key
    let ranking;
    let attendanceRanking;
    let matchesTable;

    await setGlobals();

    // --- Authentication Event Listeners ---

    // Sign In
    signInButton.addEventListener('click', async () => {
        const email = emailInput.value;
        const password = passwordInput.value;
        try {
            const userCredential = await signInWithEmailAndPassword(auth, email, password);
            document.getElementById("userName").textContent = auth.currentUser.displayName;
            loadPredictionWindow();
            document.getElementById("menuItems").style.display = "block";
        } catch (error) {
            console.error("Sign in error:", error);
        }
    });

    // Sign Out
    document.getElementById("logOutButton").addEventListener("click", async() => {
        try {
            await signOut(auth);
            resetMainContainer("loginDiv");
            loadLoginWindow();
        } catch (error) {
            console.error("Sign out error:", error);
            loadLoginWindow();
        }
    });

    addPredictionButton.addEventListener("click", async (event) => {
        event.preventDefault();
        const homeScore = getPredictedScore("home");
        const awayScore = getPredictedScore("away");

        const matchid = nextMatch.id;
        const userid = auth.currentUser.uid;

        const predictionData = {
            matchId: matchid,
            scoreAwayTeam: awayScore,
            scoreHomeTeam: homeScore,
            timestamp: new Date(),
            userId: userid,
        }

        console.log(predictionData);

        if (document.getElementById("nextPredictionId").value !== ""){
            await setDoc(doc(db, "Predictions", document.getElementById("nextPredictionId").value), predictionData, {merge: true});
            alert("Voorspelling opgeslagen!");
        } else {
            try {
                await addDoc(collection(db, "Predictions"), predictionData);

                alert("Voorspelling opgeslagen!");
            } catch (error) {

                alert(error);
            }}
    });

    loginButton.addEventListener("click", () => {
        loadLoginWindow();
    });


    resetPasswordButton.addEventListener("click", () => {
        const userMail = document.getElementById("email").value;
        const check1 = userMail !== "";
        const check2 = userMail.includes("@");

        if (check1 && check2) {
            sendPasswordResetEmail(auth, userMail)
                .then(() => {
                    alert("Er is een e-mail met wachtwoord-resetlink naar je verstuurd.");
                })
                .catch((error) => {
                });
        }
    });

    function getPredictedScore(scoreType) {
        let inputFieldName;
        let hiddenFieldName;

        if (scoreType === "home") {
            inputFieldName = "home_score";
            hiddenFieldName = "predictedHomeScore";
        } else {
            inputFieldName = "away_score";
            hiddenFieldName = "predictedAwayScore";
        }

        let score;

        try {
            score = document.getElementById(inputFieldName).value;
        }
        catch(err) {
            score = document.getElementById(hiddenFieldName).value;
        }

        return score;
    }

    async function loadDataFromTable(tableName){
        const coll = collection(db, tableName);
        const snapshot = await getDocs(coll);

        const resultList = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));

        return resultList;

    }

    async function setGlobals() {
        matches = await getSortedMatches();
        nextMatch = getNextMatch(matches);
        users = await getUsers();
        allPredictions = await getAllPredictions();     // dict with matchId als key
        ranking = getRanking(users, matches, allPredictions);
        attendanceRanking = getAttendanceRanking(users, matches);
    }


    async function getUsers() {
        try {

            const userList = await loadDataFromTable("Users");
            var users = {};

            for (var i = 0; i < userList.length; i++) {
                users[userList[i]["id"]] = userList[i]["userId"];
            }

            return users;

        } catch (error) {
            console.error("Error getting users:", error);
        }
    }


    async function getSortedMatches() {
        try {
            const matchesCol = collection(db, "Matches");
            const matchesQuery = query(matchesCol, orderBy("kickoffTime"));
            const matchSnapshot = await getDocs(matchesQuery);
            const matchList = matchSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));

            const matches = {};
            for (var i = 0; i < matchList.length; i++){
                matches[matchList[i]["id"]] = matchList[i];
            }

            return matches;

        } catch (error) {
            console.error("Error getting matches:", error);
        }

    }

    function getNextMatch(matches){
        const currentDate = new Date();

        for (const [key, value] of Object.entries(matches)) {
            if (value["kickoffTime"].toDate() > currentDate) {
                return value;
            }
        }
    }

    function getCurrentMatch(matches){
        const currentDate = new Date();

        for (const [key, value] of Object.entries(matches)){
            if (value["kickoffTime"].toDate() < currentDate && value["finalScore"] === ""){
                return value;
            }
        }

        return null;
    }

    function timestampToFullDateRepr(timestamp){
        const dateObj = timestamp.toDate();

        const day = dateObj.getDate().toString().padStart(2, '0');
        const month = (dateObj.getMonth() + 1).toString().padStart(2, '0'); // Maanden zijn 0-indexed
        const year = dateObj.getFullYear();

        const hours = dateObj.getHours().toString().padStart(2, '0');
        const minutes = dateObj.getMinutes().toString().padStart(2, '0');

        return `${day}-${month}-${year} ${hours}:${minutes}`;     // backticks zijn belangrijk
    }

    function getAttendanceRanking(users, matches) {
        var attendancePoints = {};
        var attendanceRanking = [];
        var attendees = "";

        for (const user_name of Object.keys(users)) {
            attendancePoints[user_name] = 0;
        }

        for (const [match_id, match_details] of Object.entries(matches)){
            const ajaxPlayingHome = (match_details["home_team"] === "Ajax");
            if (ajaxPlayingHome) {
                attendees = match_details["attendees"] ?? "";
                for (const [user_name, user_id] of Object.entries(users)){
                    if (attendees.includes(user_name)){
                        let currentPoints = attendancePoints[user_name] ?? 0;
                        attendancePoints[user_name] = currentPoints + 1;
                    }
                }
            }

        }

        for (const [user_name, points] of Object.entries(attendancePoints)) {
            attendanceRanking.push({naam: user_name, score: points});
        }

        attendanceRanking.sort((a, b) => b.score - a.score);

        var ranking = {};

        for (var i = 0; i < attendanceRanking.length; i++){
            ranking[attendanceRanking[i].naam] = attendanceRanking[i].score;
        }

        return ranking;

    }

    function getRanking(users, matches, predictions) {
        var userRanking = [];

        for (const [user_name, user_id] of Object.entries(users)){
            var baseScore = 0;
            var goalsAjaxScore = 0;
            var goalDiffScore = 0;
            var winnerScore = 0;
            for (const [match_id, match_details] of Object.entries(matches)) {
                const match_predictions = predictions[match_id] ?? {};
                const user_prediction = match_predictions[user_id] ?? [""];
                const ajaxPlayingHome = match_details["home_team"] === "Ajax";
                let points = getPredictionPoints(user_prediction[0], match_details["finalScore"], ajaxPlayingHome);
                winnerScore += points[0];
                goalsAjaxScore += points[1];
                goalDiffScore += points[2];
            }
            let totalScore = winnerScore + goalsAjaxScore + goalDiffScore
            userRanking.push({naam: user_name, score: totalScore, wS: winnerScore, gA: goalsAjaxScore, gD: goalDiffScore});
        }
        userRanking.sort((a, b) => b.score - a.score);

        var ranking = {};

        for (var i = 0; i < userRanking.length; i++){
            ranking[userRanking[i].naam] = [userRanking[i].score, userRanking[i].wS, userRanking[i].gA, userRanking[i].gD];
        }

        return ranking;

    }

    function getPredictionPoints(prediction, finalScore, ajaxPlaysHome) {
        if (prediction === "" || finalScore === ""){
            return [0, 0, 0];
        } else if (prediction === finalScore) {
            return [1, 1, 1];
        }

        var points = [0, 0, 0];

        const predictedScore = prediction.split("-");
        const predictedHomeGoals = predictedScore[0];
        const predictedAwayGoals = predictedScore[1];
        const predictedDiff = predictedHomeGoals - predictedAwayGoals;

        const realizedScore = finalScore.split("-");
        const realizedHomeGoals = realizedScore[0];
        const realizedAwayGoals = realizedScore[1];
        const realizedDiff = realizedHomeGoals - realizedAwayGoals;

        // 1 point if winner is correct

        if (predictedHomeGoals > predictedAwayGoals && realizedHomeGoals > realizedAwayGoals) {
            points[0] = 1;
        } else if (predictedHomeGoals === predictedAwayGoals && realizedHomeGoals === realizedAwayGoals) {
            points[0] = 1;
        }  else if (predictedHomeGoals < predictedAwayGoals && realizedHomeGoals < realizedAwayGoals) {
            points[0] = 1;
        }

        // 1 point if Ajax goals is correct
        const homeGoalsCorrect = predictedHomeGoals === realizedHomeGoals;
        const awayGoalsCorrect = predictedAwayGoals === realizedAwayGoals;

        if ( (ajaxPlaysHome && homeGoalsCorrect) || (!ajaxPlaysHome && awayGoalsCorrect)) {
            points[1] = 1;
        }

        // 1 point if goalDiff is correct

        if (predictedDiff === realizedDiff) {
            points[2] = 1;
        }

        return points
    }


    async function getAllPredictions(){
        const predictions = await loadDataFromTable("Predictions");
        var predictionsDict = {};


        for (var i = 0; i < predictions.length; i++){
            const home_score = predictions[i]["scoreHomeTeam"].toString();
            const away_score = predictions[i]["scoreAwayTeam"].toString();
            const user_id = predictions[i]["userId"];
            if (!(predictions[i]["matchId"] in predictionsDict)) {
                predictionsDict[predictions[i]["matchId"]] = {}
            }
            predictionsDict[predictions[i]["matchId"]][user_id] = [home_score + "-" + away_score, predictions[i]["id"]];
        }

        return predictionsDict;
    }

    async function loadPredictionTables() {
        console.log("loading prediction table");

        // set next_match_date, home_team and away_team
        document.getElementById("next_match_date").textContent = timestampToFullDateRepr(nextMatch["kickoffTime"]);
        document.getElementById("home_team").textContent = nextMatch["home_team"];
        document.getElementById("away_team").textContent = nextMatch["away_team"];

        const currentMatch = getCurrentMatch(matches);

        let tableMatches;

        if (currentMatch === null) {
            tableMatches = [nextMatch]
        } else {
            tableMatches = [currentMatch, nextMatch]
        }

        // Fill Prediction Table by looping over users and retrieving their prediction (if present)

        const predictionTable = document.getElementById("prediction_table");

        for (let i=0; i<tableMatches.length; i++) {

            let match = tableMatches[i];
            let matchPredictions = allPredictions[match["id"]] ?? {};

            for (const [key, value] of Object.entries(users)) {

                let row = predictionTable.insertRow(-1);
                let cell = row.insertCell();
                cell.textContent = key;

                let userPrediction = matchPredictions[value] ?? ["", ""];
                cell = row.insertCell();

                cell.textContent = userPrediction[0];
                if (value === auth.currentUser.uid) {
                    if (userPrediction[0] !== "") {
                        let home_score = userPrediction[0].split("-")[0];
                        let away_score = userPrediction[0].split("-")[1];
                        document.getElementById("home_score").value = home_score;
                        document.getElementById("predictedHomeScore").value = home_score;
                        document.getElementById("away_score").value = away_score;
                        document.getElementById("predictedAwayScore").value = away_score;
                        document.getElementById("nextPredictionId").value = userPrediction[1];
                    } else {
                        document.getElementById("predictedHomeScore").value = 0;
                        document.getElementById("predictedAwayScore").value = 0;
                    }
                }
            }

        }

        console.log("fill ranking table");
        // fill ranking table

        const rankingTable = document.getElementById("ranking_table");

        for (const [userName, userScores] of Object.entries(ranking)) {
            const tr = rankingTable.insertRow(-1)

            const userCell = tr.insertCell(0);
            userCell.innerHTML = userName;

            const scoreWinnerCell = tr.insertCell(1);
            scoreWinnerCell.innerHTML = userScores[1];

            const scoreAjaxCell = tr.insertCell(2);
            scoreAjaxCell.innerHTML = userScores[2];

            const scoreGoalDiffCell = tr.insertCell(3);
            scoreGoalDiffCell.innerHTML = userScores[3];

            const totalScoreCell = tr.insertCell(4);
            totalScoreCell.innerHTML = userScores[0];

        }

        // fill attendance ranking table

        const attendanceRankingTable = document.getElementById("attendance_ranking_table");

        for (const [userName, userScore] of Object.entries(attendanceRanking)) {
            const tr = attendanceRankingTable.insertRow(-1);

            const userCell = tr.insertCell(0);
            userCell.innerHTML = userName;

            const scoreCell = tr.insertCell(1);
            scoreCell.innerHTML = userScore;
        }

        document.getElementById("match_prediction").hidden = false;
    }

    function resetMainContainer(activeDivName){
        for (let i = 0; i < mainContainer.children.length; i++) {
            const child = mainContainer.children[i];
            if (child.id !== activeDivName) {
                child.style.display = "none";
            } else {
                child.style.display = "block";
            }
        }

        resetTable("prediction_table", false);
        resetTable("ranking_table", false);
        resetTable("attendance_ranking_table", false);
        resetTable("allMatches", false);
    }

    function loadLoginWindow(){
        resetMainContainer("loginDiv");
        authSectionDiv.style.display = "block";
        mainContainer.appendChild(authSectionDiv);
    }

    function loadPredictionWindow(){
        resetMainContainer("predictionDiv");

        loadPredictionTables();
        predictionDiv.style.display = "block";
        mainContainer.appendChild(predictionDiv);
        document.getElementById("loginDiv").style.display = "none";
        document.getElementById("userInfoDiv").style.display = "block";
    }

    document.getElementById("homeButton").addEventListener("click", async () => {
        loadPredictionWindow();
    });

    document.getElementById("rulesButton").addEventListener("click", () => {
       resetMainContainer("rules");
       document.getElementById("rules").style.display = "block";
    });


    document.getElementById("allMatchesButton").addEventListener("click", () => {
        resetMainContainer("matchesDiv");
        getMatchesTable(users, matches, allPredictions);
        document.getElementById("matchesDiv").style.display = "block";
        mainContainer.appendChild(document.getElementById("matchesDiv"))
    });

    function getMatchesTable(users, matches, allPredictions) {

        const matchTable = document.getElementById("allMatches");
        const headerRow = matchTable.rows[0];

        for (const username of Object.keys(users)) {
            if (!headerRow.innerHTML.includes(username)) {
                let th = document.createElement("th");
                th.textContent = username;
                headerRow.appendChild(th);
            }
        }

        if (!headerRow.innerHTML.includes("Aanwezig")) {
            let th = document.createElement("th");
            th.textContent = "Aanwezig";
            headerRow.appendChild(th);
        }

        let round = 1;

        for (const currentMatch of Object.values(matches)) {
            let tr = document.createElement("tr");

            let matchDate = timestampToFullDateRepr(currentMatch["kickoffTime"]);

            let rowData = [round, matchDate, currentMatch["home_team"], currentMatch["away_team"],
                currentMatch["finalScore"]];

            let matchPredictions = allPredictions[currentMatch["id"]] ?? {};

            for (const userid of Object.values(users)) {
                let userPrediction = matchPredictions[userid] ?? ["", ""];
                rowData.push(userPrediction[0]);
            }

            let attendance = currentMatch["attendees"] ?? "";
            rowData.push(attendance);

            for (const data of rowData) {
                let cell = tr.insertCell();
                cell.textContent = data;
            }

            matchTable.appendChild(tr);
            round += 1;

        }

    }

    function resetTable(tableName, resetHeaders) {

        const table = document.getElementById(tableName);

        if (!table) {
            return;
        }

        const startRow = resetHeaders ? 0 : 1;

        while (table.rows.length > startRow) {
            table.deleteRow(startRow)
        }

    }


</script>
</body>
</html>















