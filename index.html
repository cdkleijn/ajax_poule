<html lang="en">
<meta name="viewport" content="width=device-width, initial_scale=1.0">


<head>
    <title>Soccer Predictions</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="navbar">
    <h3> Ajax Poule vak 402 </h3>
    <div id="loginDiv">
        <button class="dropbtn" id="loginButton">
            <i class="fas fa-user user-icon dropbtn" id="userIcon"> </i> Login
        </button>
    </div>
    <div id="userInfoDiv" style="display: none;">
        <button class="dropbtn" id="userInfoButton">
            <i class="fas fa-user user-icon dropbtn" id="userInfoIcon"></i> <span id="userName"> Gebruikersnaam </span>
        </button>
    </div>
</div>

<div id="mainContainer">
</div>

<div class="login-window" id="auth-section" style="display: none;">
    <input type="email" id="email" placeholder="Email">
    <input type="password" id="password" placeholder="Password">
    <button id="signInButton">Log in</button>
    <button id="updatePassword"> Reset wachtwoord </button>
</div>

<div id="match_prediction" style="display: none;">
    <div class="tables-container">
        <table id="match_table" class="prediction-tables">
            <caption> Eerstvolgende wedstrijd </caption>
            <tr>
                <th> Datum </th>
                <th> Thuis </th>
                <th> Uit </th>
            </tr>
            <tbody></tbody>
        </table>
        <table id="prediction_table" class="prediction-tables">
            <caption> Voorspellingen </caption>
            <tbody></tbody>
        </table>
    </div>
    <button id="addPrediction" style="margin-top: 20px"> Verstuur voorspelling </button>
    <div class="tables-container" style="margin-top: 20px">
        <table id="ranking_table" class="prediction-tables">
            <caption> Stand </caption>
            <tr>
                <th> Naam </th>
                <th> Winnaar </th>
                <th> Ajax Goals </th>
                <th> Doelsaldo </th>
                <th> Totaal </th>
            </tr>
            <tbody></tbody>
        </table>
        <table id="attendance_ranking_table" class="prediction-tables">
            <caption> Aanwezigheid </caption>
            <tr>
                <th> Naam </th>
                <th> Aantal </th>
            </tr>
            <tbody></tbody>
        </table>
    </div>
    <button id="refreshPrediction" style="margin-top: 20px"> Refresh  </button>
</div>

<div id="userDiv" style="display: none;">
    <div id="userData">
        <table id="userInfoTable">
            <tr>
                <td><strong>Gebruikersnaam</strong></td>
                <td id="displayName">Laden...</td>
            </tr>
            <tr>
                <td><strong>Emailadres</strong></td>
                <td id="userEmail">Laden...</td>
            </tr>
            <tr>
                <td><strong>Nieuw e-mailadres</strong></td>
                <td><input type="email" id="newEmail" placeholder="Nieuw e-mailadres..."></td>
            </tr>
        </table>

        <button id="updateUserInfoButton" style="margin-top: 20px">Update Gebruikersinformatie</button>
        <button id="signOutButton" style="margin-top: 20px">Log uit</button>
        <button id="backToPrediction" style="margin-top: 20px"> Terug </button>

    </div>
</div>


<div id="nextPredictionId" style="display: none;"></div>

<script type="module">
    // Import the core Firebase App and Cloud Firestore services
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";

    import { getAuth, sendPasswordResetEmail, updateProfile, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
    import { getFirestore, collection, getDocs, addDoc, setDoc, doc, query, orderBy } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

    // Your web app's Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyADh9mOGIa9tK8sGb9fu6PHUm-anH8aRPw",
        authDomain: "voetbalpoule-aef18.firebaseapp.com",
        databaseURL: "https://voetbalpoule-aef18-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "voetbalpoule-aef18",
        storageBucket: "voetbalpoule-aef18.firebasestorage.app",
        messagingSenderId: "678980778754",
        appId: "1:678980778754:web:582c0f3d6487651b9ea01b"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);

    // Initialize Cloud Firestore and get a reference to the service
    const db = getFirestore(app);

    // Get references to HTML elements
    const mainContainer = document.getElementById('mainContainer');
    const predictionDiv = document.getElementById("match_prediction");
    const auth = getAuth(app);
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');
    const loginButton = document.getElementById("loginButton");
    const userInfoButton = document.getElementById("userInfoButton");
    const signInButton = document.getElementById('signInButton');
    const signOutButton = document.getElementById('signOutButton');
    const userInfoDiv = document.getElementById('user-info');
    const authSectionDiv = document.getElementById('auth-section');
    const userIdSpan = document.getElementById('userId');
    const addPredictionButton = document.getElementById("addPrediction");
    const resetPasswordButton = document.getElementById("updatePassword");
    const returnButton = document.getElementById("backToPrediction");

    var nextMatch = "";

    window.addEventListener("load", async (event) => {
        try {
            await signOut(auth);
            // No need to manually update UI here, onAuthStateChanged will handle it
        } catch {
            console.log("No user signed in");
        }
        resetMainContainer();
    });

    // --- Authentication Event Listeners ---

    // Sign In
    signInButton.addEventListener('click', async () => {
        const email = emailInput.value;
        const password = passwordInput.value;
        try {
            const userCredential = await signInWithEmailAndPassword(auth, email, password);
            loadPredictionWindow();
        } catch (error) {
            console.error("Sign in error:", error);
        }
    });

    // Sign Out
    signOutButton.addEventListener('click', async () => {
        try {
            await signOut(auth);
            // No need to manually update UI here, onAuthStateChanged will handle it
        } catch (error) {
            authMessage.textContent = `Error signing out: ${error.message}`;
            console.error("Sign out error:", error);
        }
    });

    addPredictionButton.addEventListener("click", async () => {
        const prediction = document.getElementById("prediction_field").value;
        const scores = prediction.split("-");
        const homeScore = parseInt(scores[0].trim());
        const awayScore = parseInt(scores[1].trim());
        const matchid = nextMatch.id;
        const userid = auth.currentUser.uid;

        const predictionData = {
            matchId: matchid,
            scoreAwayTeam: awayScore,
            scoreHomeTeam: homeScore,
            timestamp: new Date(),
            userId: userid,
        }

        if (document.getElementById("nextPredictionId").value !== ""){
            await setDoc(doc(db, "Predictions", document.getElementById("nextPredictionId").value), predictionData, {merge: true});
            alert("Voorspelling opgeslagen!");
        } else {


            try {
                await addDoc(collection(db, "Predictions"), predictionData);

                alert("Voorspelling opgeslagen!");
            } catch (error) {

                alert(error);
            }}
    });

    loginButton.addEventListener("click", () => {
        loadLoginWindow();
    });

    document.getElementById("refreshPrediction").addEventListener("click", () => {
        loadPredictionWindow();
    });

    userInfoButton.addEventListener("click", () => {
        ;
    });

    updateUserInfoButton.addEventListener("click", () => {
        const newDisplayName = document.getElementById("newDisplayName").value;
        const newEmail = document.getElementById("newEmail").value;
        if (newDisplayName !== ""){
            updateProfile(auth.currentUser, {displayName: newDisplayName});
            alert("Gebruikersnaam bijgewerkt");
        }
        if (newEmail !== ""){
            updateProfile(auth.currentUser, {email: newEmail});
            alert("Gebruikersnaam bijgewerkt");
        }
    });

    resetPasswordButton.addEventListener("click", () => {
        const userMail = document.getElementById("email").value;
        const check1 = userMail !== "";
        const check2 = userMail.includes("@");

        if (check1 && check2) {
            sendPasswordResetEmail(auth, userMail)
                .then(() => {
                    alert("Er is een e-mail met wachtwoord-resetlink naar je verstuurd.");
                })
                .catch((error) => {
                });
        }
    });

    returnButton.addEventListener("click", () => {
        loadPredictionWindow();
    });


    async function loadDataFromTable(tableName){
        const coll = collection(db, tableName);
        const snapshot = await getDocs(coll);

        const resultList = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));

        return resultList;

    }


    async function getUsers() {
        try {

            const userList = await loadDataFromTable("Users");
            var users = {};

            for (var i = 0; i < userList.length; i++) {
                users[userList[i]["id"]] = userList[i]["userId"];
            }

            return users;

        } catch (error) {
            console.error("Error getting users:", error);
        }
    }


    async function getSortedMatches() {
        try {
            const matchesCol = collection(db, "Matches");
            const matchesQuery = query(matchesCol, orderBy("kickoffTime"));
            const matchSnapshot = await getDocs(matchesQuery);
            const matchList = matchSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));

            const matches = {};
            for (var i = 0; i < matchList.length; i++){
                matches[matchList[i]["id"]] = matchList[i];
            }

            return matches;

        } catch (error) {
            console.error("Error getting matches:", error);
        }

    }

    function getNextMatch(matches){
        const currentDate = new Date();

        for (const [key, value] of Object.entries(matches)) {
            if (value["kickoffTime"].toDate() > currentDate) {
                return value;
            }
        }
    }

    function timestampToFullDateRepr(timestamp){
        const dateObj = timestamp.toDate();

        const day = dateObj.getDate().toString().padStart(2, '0');
        const month = (dateObj.getMonth() + 1).toString().padStart(2, '0'); // Maanden zijn 0-indexed
        const year = dateObj.getFullYear();

        const hours = dateObj.getHours().toString().padStart(2, '0');
        const minutes = dateObj.getMinutes().toString().padStart(2, '0');

        return `${day}-${month}-${year} ${hours}:${minutes}`;     // backticks zijn belangrijk
    }

    function getAttendanceRanking(users, matches) {
        var attendancePoints = {};
        var attendanceRanking = [];
        var attendees = "";

        for (const user_name of Object.keys(users)) {
            attendancePoints[user_name] = 0;
        }

        for (const [match_id, match_details] of Object.entries(matches)){
            const ajaxPlayingHome = (match_details["home_team"] == "Ajax");
            if (ajaxPlayingHome) {
                attendees = match_details["attendees"] ?? "";
                for (const [user_name, user_id] of Object.entries(users)){
                    if (attendees.includes(user_name)){
                        let currentPoints = attendancePoints[user_name] ?? 0;
                        attendancePoints[user_name] = currentPoints + 1;
                    }
                }
            }

        }

        for (const [user_name, points] of Object.entries(attendancePoints)) {
            attendanceRanking.push({naam: user_name, score: points});
        }

        attendanceRanking.sort((a, b) => b.score - a.score);

        var ranking = {};

        for (var i = 0; i < attendanceRanking.length; i++){
            ranking[attendanceRanking[i].naam] = attendanceRanking[i].score;
        }

        return ranking;

    }

    function getRanking(users, matches, predictions) {
        var userRanking = [];

        for (const [user_name, user_id] of Object.entries(users)){
            var baseScore = 0;
            var goalsAjaxScore = 0;
            var goalDiffScore = 0;
            var winnerScore = 0;
            for (const [match_id, match_details] of Object.entries(matches)) {
                const match_predictions = predictions[match_id] ?? {};
                const user_prediction = match_predictions[user_id] ?? [""];
                const ajaxPlayingHome = match_details["home_team"] === "Ajax";
                let points = getPredictionPoints(user_prediction[0], match_details["finalScore"], ajaxPlayingHome);
                winnerScore += points[0];
                goalsAjaxScore += points[1];
                goalDiffScore += points[2];
            }
            let totalScore = winnerScore + goalsAjaxScore + goalDiffScore
            userRanking.push({naam: user_name, score: totalScore, wS: winnerScore, gA: goalsAjaxScore, gD: goalDiffScore});
        }
        userRanking.sort((a, b) => b.score - a.score);

        var ranking = {};

        for (var i = 0; i < userRanking.length; i++){
            ranking[userRanking[i].naam] = [userRanking[i].score, userRanking[i].wS, userRanking[i].gA, userRanking[i].gD];
        }

        return ranking;

    }

    function getPredictionPoints(prediction, finalScore, ajaxPlaysHome) {
        if (prediction === "" || finalScore === ""){
            return [0, 0, 0];
        } else if (prediction === finalScore) {
            return [1, 1, 1];
        }

        var points = [0, 0, 0];

        const predictedScore = prediction.split("-");
        const predictedHomeGoals = predictedScore[0];
        const predictedAwayGoals = predictedScore[1];
        const predictedDiff = predictedHomeGoals - predictedAwayGoals;

        const realizedScore = finalScore.split("-");
        const realizedHomeGoals = realizedScore[0];
        const realizedAwayGoals = realizedScore[1];
        const realizedDiff = realizedHomeGoals - realizedAwayGoals;

        // 1 point if winner is correct

        if (predictedHomeGoals > predictedAwayGoals && realizedHomeGoals > realizedAwayGoals) {
            points[0] = 1;
        } else if (predictedHomeGoals === predictedAwayGoals && realizedHomeGoals === realizedAwayGoals) {
            points[0] = 1;
        }  else if (predictedHomeGoals < predictedAwayGoals && realizedHomeGoals < realizedAwayGoals) {
            points[0] = 1;
        }

        // 1 point if Ajax goals is correct
        const homeGoalsCorrect = predictedHomeGoals == realizedHomeGoals;
        const awayGoalsCorrect = predictedAwayGoals == realizedAwayGoals;

        if ( (ajaxPlaysHome && homeGoalsCorrect) || (!ajaxPlaysHome & awayGoalsCorrect)) {
            points[1] = 1;
        }

        // 1 point if goalDiff is correct

        if (predictedDiff === realizedDiff) {
            points[2] = 1;
        }

        return points
    }


    async function getAllPredictions(){
        const predictions = await loadDataFromTable("Predictions");
        var predictionsDict = {};


        for (var i = 0; i < predictions.length; i++){
            const home_score = predictions[i]["scoreHomeTeam"].toString();
            const away_score = predictions[i]["scoreAwayTeam"].toString();
            const user_id = predictions[i]["userId"];
            if (!(predictions[i]["matchId"] in predictionsDict)) {
                predictionsDict[predictions[i]["matchId"]] = {}
            }
            predictionsDict[predictions[i]["matchId"]][user_id] = [home_score + "-" + away_score, predictions[i]["id"]];
        }

        return predictionsDict;
    }

    async function loadPredictionTables() {
        console.log("loading prediction table");

        const users = await getUsers();
        const matches = await getSortedMatches();

        nextMatch = getNextMatch(matches);

        const allPredictions = await getAllPredictions();     // dict with matchId als key
        const matchPredictions = allPredictions[nextMatch["id"]] ?? {};
        const authuserPrediction = matchPredictions[auth.currentUser.uid] ?? ["", ""];
        document.getElementById("nextPredictionId").value = authuserPrediction[1] ?? "";

        const ranking = getRanking(users, matches, allPredictions);
        const attendanceRanking = getAttendanceRanking(users, matches);

        // Fill Match Table
        const matchTable = document.getElementById("match_table");
        var row = matchTable.insertRow(1);
        var dateCell = row.insertCell(0);
        var homeTeamCell = row.insertCell(1);
        var awayTeamCell = row.insertCell(2);

        const formattedDate = timestampToFullDateRepr(nextMatch["kickoffTime"]);

        dateCell.innerHTML = formattedDate;
        homeTeamCell.innerHTML = nextMatch["home_team"];
        awayTeamCell.innerHTML = nextMatch["away_team"];

        // Fill Prediction Table by looping over users and retrieving their prediction (if present)

        const predictionTable = document.getElementById("prediction_table");

        const headerRow = document.createElement("tr");
        for (const [key, value] of Object.entries(users)) {
            const th = document.createElement("th");
            th.textContent = key;
            headerRow.appendChild(th);
        }
        predictionTable.appendChild(headerRow);

        const predictionRow = document.createElement("tr");
        for (const [key, value] of Object.entries(users)) {
            const td = document.createElement("td");
            const userPrediction = matchPredictions[value] ?? ["", ""];
            if (key === auth.currentUser.displayName) {
                const inputField = document.createElement("input");
                inputField.setAttribute("type", "text");
                inputField.id = "prediction_field";
                inputField.value = userPrediction[0];
                inputField.background
                td.appendChild(inputField);
                td.style.backgroundColor = '#D2122E'
            } else {
                td.textContent = userPrediction[0];
            }
            predictionRow.appendChild(td);
        }
        predictionTable.appendChild(predictionRow);

        console.log("fill ranking table");
        // fill ranking table

        const rankingTable = document.getElementById("ranking_table");

        for (const [userName, userScores] of Object.entries(ranking)) {
            const tr = rankingTable.insertRow(-1)

            const userCell = tr.insertCell(0);
            userCell.innerHTML = userName;

            const scoreWinnerCell = tr.insertCell(1);
            scoreWinnerCell.innerHTML = userScores[1];

            const scoreAjaxCell = tr.insertCell(2);
            scoreAjaxCell.innerHTML = userScores[2];

            const scoreGoalDiffCell = tr.insertCell(3);
            scoreGoalDiffCell.innerHTML = userScores[3];

            const totalScoreCell = tr.insertCell(4);
            totalScoreCell.innerHTML = userScores[0];

        }

        // fill attendance ranking table

        const attendanceRankingTable = document.getElementById("attendance_ranking_table");

        for (const [userName, userScore] of Object.entries(attendanceRanking)) {
            const tr = attendanceRankingTable.insertRow(-1);

            const userCell = tr.insertCell(0);
            userCell.innerHTML = userName;

            const scoreCell = tr.insertCell(1);
            scoreCell.innerHTML = userScore;
        }

        document.getElementById("match_prediction").hidden = false;
    }

    function resetMainContainer(){
        while (mainContainer.firstChild) {
            mainContainer.removeChild(mainContainer.firstChild);
        }
    }

    function loadLoginWindow(){
        resetMainContainer();
        authSectionDiv.style.display = "block";
        mainContainer.appendChild(authSectionDiv);
    }

    function loadPredictionWindow(){
        resetTable("match_table", false)
        resetTable("prediction_table", true)
        resetTable("ranking_table", false)
        resetTable("attendance_ranking_table", false)
        resetMainContainer();

        loadPredictionTables();
        predictionDiv.style.display = "block";
        mainContainer.appendChild(predictionDiv);
        document.getElementById("loginDiv").style.display = "none";
        document.getElementById("userInfoDiv").style.display = "block";
        document.getElementById("userName").textContent = auth.currentUser.displayName;
        document.getElementById("userEmail").textContent = auth.currentUser.email;
    }

    function resetTable(tableName, resetHeaders) {

        const table = document.getElementById(tableName);

        if (!table) {
            return;
        }

        const startRow = resetHeaders ? 0 : 1;

        while (table.rows.length > startRow) {
            table.deleteRow(startRow)
        }

    }

    function loadUserWindow(){
        resetMainContainer();
        const userDiv = document.getElementById("userDiv");
        userDiv.style.display = "block";
        mainContainer.appendChild(userDiv);
    }


</script>
</body>
</html>















